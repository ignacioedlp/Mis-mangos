generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id            String         @id @default(uuid())
  email         String         @unique
  name          String?
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]
  categories    Category[]
  expenses      Expense[]
  salaries      Salary[]
  notifications Notification[]
  reports       Report[]
  goals         Goal[]

  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

/// Frequency of a recurring expense
enum ExpenseFrequency {
  WEEKLY
  MONTHLY
  ANNUAL
  ONE_TIME // For non-recurring expenses like car tinting, repairs, etc.
}

model Category {
  id               String   @id @default(uuid())
  name             String
  budgetPercentage Decimal? @db.Decimal(5, 2) // Percentage of total income (0.00 to 100.00)
  userId           String
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  subcategories Subcategory[]
  expenses      Expense[]
  goals         Goal[]

  @@unique([userId, name])
  @@index([budgetPercentage]) // Index for budget queries
  @@map("category")
}

model Subcategory {
  id         String   @id @default(uuid())
  name       String
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  expenses Expense[]

  @@unique([categoryId, name])
  @@map("subcategory")
}

model Expense {
  id              String           @id @default(uuid())
  name            String
  estimatedAmount Decimal          @db.Decimal(12, 2)
  frequency       ExpenseFrequency
  active          Boolean          @default(true)
  deletedAt       DateTime? // Soft delete - null means not deleted
  userId          String
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  categoryId      String
  category        Category         @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  subcategoryId   String
  subcategory     Subcategory      @relation(fields: [subcategoryId], references: [id], onDelete: Cascade)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  occurrences ExpenseOccurrence[]

  @@index([userId])
  @@index([categoryId])
  @@index([subcategoryId])
  @@index([deletedAt]) // Index for soft delete queries
  @@map("expense")
}

model ExpenseOccurrence {
  id        String    @id @default(uuid())
  expenseId String
  expense   Expense   @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  year      Int
  month     Int // 1-12
  isPaid    Boolean   @default(false)
  isSkipped Boolean   @default(false) // Skip this occurrence for this month
  paidAt    DateTime?
  skippedAt DateTime? // When was this occurrence skipped
  amount    Decimal?  @db.Decimal(12, 2) // real amount for this month (optional)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([expenseId, year, month])
  @@index([year, month])
  @@index([isSkipped]) // Index for skip queries
  @@map("expense_occurrence")
}

model Salary {
  id        String   @id @default(uuid())
  amount    Decimal  @db.Decimal(12, 2)
  year      Int
  month     Int // 1-12
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, year, month])
  @@index([year, month])
  @@map("salary")
}

/// Types of notifications
enum NotificationType {
  BUDGET_EXCEEDED // Category budget exceeded
  BUDGET_WARNING // Near budget limit (80%+)
  PAYMENT_REMINDER // Upcoming payment due
  MONTHLY_SUMMARY // End of month summary
  SAVINGS_MILESTONE // Savings goal achieved
  SPENDING_SPIKE // Unusual spending detected
  BUDGET_AVAILABLE // Money available to spend
}

/// Priority levels for notifications
enum NotificationPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model Notification {
  id         String               @id @default(uuid())
  userId     String
  user       User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  type       NotificationType
  priority   NotificationPriority @default(MEDIUM)
  title      String
  message    String
  isRead     Boolean              @default(false)
  isArchived Boolean              @default(false)

  // Contextual data (JSON)
  metadata Json? // Store category, amount, etc.

  // Action buttons data
  actionUrl   String? // URL to navigate to
  actionLabel String? // Button text

  createdAt  DateTime  @default(now())
  readAt     DateTime?
  archivedAt DateTime?

  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@index([type])
  @@map("notification")
}

/// Types of reports
enum ReportType {
  MONTHLY_SUMMARY
  BUDGET_ANALYSIS
  SPENDING_TRENDS
  CATEGORY_BREAKDOWN
  YEARLY_OVERVIEW
  CUSTOM
}

/// Report generation status
enum ReportStatus {
  PENDING
  GENERATING
  COMPLETED
  FAILED
}

model Report {
  id          String       @id @default(uuid())
  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        ReportType
  status      ReportStatus @default(PENDING)
  title       String
  description String?

  // Report parameters
  startDate  DateTime
  endDate    DateTime
  categories String[] // Category IDs to include

  // Generated content
  data     Json? // Report data in JSON format
  fileUrl  String? // URL to generated PDF/Excel file
  fileName String? // Original file name

  // Metadata
  generatedAt    DateTime?
  downloadCount  Int       @default(0)
  lastDownloadAt DateTime?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  expiresAt DateTime? // Auto-delete after X days

  @@index([userId, createdAt])
  @@index([userId, type])
  @@index([status])
  @@map("report")
}

/// Types of goals
enum GoalType {
  SAVINGS // Ahorrar una cantidad específica
  DEBT_PAYMENT // Pagar una deuda
  EXPENSE_REDUCTION // Reducir gastos en una categoría
  CUSTOM // Objetivo personalizado
}

/// Goal status
enum GoalStatus {
  ACTIVE
  COMPLETED
  CANCELLED
  PAUSED
}

model Goal {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Goal details
  name        String
  description String?
  type        GoalType
  status      GoalStatus @default(ACTIVE)

  // Financial targets
  targetAmount  Decimal @db.Decimal(12, 2) // Cantidad objetivo
  currentAmount Decimal @default(0) @db.Decimal(12, 2) // Cantidad actual acumulada

  // Optional category link (for EXPENSE_REDUCTION goals)
  categoryId String?
  category   Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  // Timeline
  startDate   DateTime  @default(now())
  targetDate  DateTime? // Fecha objetivo (opcional)
  completedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, status])
  @@index([userId, createdAt])
  @@map("goal")
}
